#' Run komap main function
#'
#' @param input.cov A covariance matrix of the target disease with colnames and rownames equal to variable names.
#' @param is.wide If \code{TRUE}, \code{input.cov} is treated as a normal p by p covariance matrix. If \code{FALSE}, treat \code{input.cov} as in a long format with three columns (the first two indicating row and column names and the last one indicating covariance value). If only inputing the lower/upper triangle part, the function will automatically fill the other side assuming symmetric covariance matrix.
#' @param target.code Main phecode of the target disease.
#' @param target.cui Main NLP feature (CUI) of the target disease, can be NULL if NLP features are not available.
#' @param nm.utl Variable name of health utility score.
#' @param nm.multi Variable name indicating the site id. Default is NULL for the single site case.
#' @param dict Dictionary mapping feature id (the first column) to full description (the second column). Default is set to be NULL.
#' @param codify.feature A vector of codified features related to the target code. Can be generated by KESER or ONCE (Codisearch). If \code{NULL}, then use all features in \code{input.cov}.
#' @param nlp.feature A vector of NLP features related to the target code. Can be generated by ONCE (CUIsearch). If \code{NULL}, then use all features in \code{input.cov}.
#' @param pred If \code{TRUE}, predict disease scores for individual data.
#' @param eval.real If \code{TRUE}, evaluate model performance based on prediction of individual data with gold labels.
#' @param eval.sim If \code{TRUE}, evaluate model performance based on conditional covariance matrices, conditional mean vectors and prevalence of the target disease.
#' @param mu0 Conditional mean vector of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param mu1 Conditional mean vector of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same length and in the same feature order as \code{mu0}.
#' @param var0 Conditional covariance matrix of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param var1 Conditional covariance matrix of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same dimension and in the same feature order as \code{var0}.
#' @param prev_Y Prevalence of the target disease. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param B The number of samples to calculate simulated AUC, given the conditional Gaussian assumption. Default is 10000.
#' @param dat.part Patient-level data for prediction. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param nm.id Name of the patient id column in \code{dat.part} and \code{gold.label}. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param nm.pi The column name of sample probability in \code{gold.label} if individuals in \code{gold.label} are generated with different probabilities. Default is \code{NULL}, meaning a uniform sample distribution.
#' @param nm.y The column name of labels in \code{gold.label}. Must be provided if \code{eval.real}=\code{TRUE}.
#' @returns A list containing estimation and/or prediction and/or evaluation results by running KOMAP.
#' @export
#' @importFrom rlang .data
KOMAP_corrupt <- function(input.cov.train, input.cov.valid, is.wide = TRUE, target.code, target.cui, nm.disease,
                          nm.utl, nm.corrupt.code, nm.corrupt.cui,
                          nm.multi = NULL, dict = NULL,
                          codify.feature = NULL, nlp.feature = NULL,
                          pred = FALSE, eval.real = FALSE, eval.sim = TRUE,
                          mu0 = NULL, mu1 = NULL, var0 = NULL, var1 = NULL, prev_Y = NULL, B = 10000,
                          dat.part = NULL, nm.id = NULL, nm.pi = NULL, nm.y = NULL){
  oldw <- getOption("warn")
  options(warn = -1)
  if(is.null(nlp.feature)){
    cuisearch.feature = NULL
  }else{
    cuisearch.feature = nlp.feature
  }
  if(!is.wide){
    input.cov.train = as.data.frame(input.cov.train)
    unique.node = unique(c(input.cov.train[,1], input.cov.train[,2]))
    colnames(input.cov.train) = c('from', 'to', 'cov')

    input.cov.train.wide = stats::reshape(as.data.frame(input.cov.train), idvar = "from", timevar = "to",
                                    direction = "wide")
    rownames(input.cov.train.wide) = input.cov.train.wide$from; input.cov.train.wide$from = NULL
    colnames(input.cov.train.wide) = stringr::str_remove(colnames(input.cov.train.wide), '^cov\\.')
    miss.row = setdiff(unique.node, rownames(input.cov.train.wide))
    miss.row.matrix = matrix(NA, nrow = length(miss.row), ncol = ncol(input.cov.train.wide))
    rownames(miss.row.matrix) = miss.row; colnames(miss.row.matrix) = colnames(input.cov.train.wide)
    input.cov.train.wide = rbind(input.cov.train.wide, miss.row.matrix)

    miss.col = setdiff(unique.node, colnames(input.cov.train.wide))
    miss.col.matrix = matrix(NA, nrow = nrow(input.cov.train.wide), ncol = length(miss.col))
    colnames(miss.col.matrix) = miss.col; rownames(miss.col.matrix) = rownames(input.cov.train.wide)
    input.cov.train.wide = cbind(input.cov.train.wide, miss.col.matrix)

    input.cov.train = input.cov.train.wide
    input.cov.train.lower = input.cov.train[lower.tri(input.cov.train)]; input.cov.train.upper = input.cov.train[upper.tri(input.cov.train)]
    if(all(is.na(input.cov.train.lower))){
      input.cov.train[lower.tri(input.cov.train)] = input.cov.train[upper.tri(input.cov.train)]
    }else{
      if(all(is.na(input.cov.train.upper))){
        input.cov.train[upper.tri(input.cov.train)] = input.cov.train[lower.tri(input.cov.train)]
      }
    }
    input.cov.train[is.na(input.cov.train)] = 0


    input.cov.valid = as.data.frame(input.cov.valid)
    unique.node = unique(c(input.cov.valid[,1], input.cov.valid[,2]))
    colnames(input.cov.valid) = c('from', 'to', 'cov')

    input.cov.valid.wide = stats::reshape(as.data.frame(input.cov.valid), idvar = "from", timevar = "to",
                                          direction = "wide")
    rownames(input.cov.valid.wide) = input.cov.valid.wide$from; input.cov.valid.wide$from = NULL
    colnames(input.cov.valid.wide) = stringr::str_remove(colnames(input.cov.valid.wide), '^cov\\.')
    miss.row = setdiff(unique.node, rownames(input.cov.valid.wide))
    miss.row.matrix = matrix(NA, nrow = length(miss.row), ncol = ncol(input.cov.valid.wide))
    rownames(miss.row.matrix) = miss.row; colnames(miss.row.matrix) = colnames(input.cov.valid.wide)
    input.cov.valid.wide = rbind(input.cov.valid.wide, miss.row.matrix)

    miss.col = setdiff(unique.node, colnames(input.cov.valid.wide))
    miss.col.matrix = matrix(NA, nrow = nrow(input.cov.valid.wide), ncol = length(miss.col))
    colnames(miss.col.matrix) = miss.col; rownames(miss.col.matrix) = rownames(input.cov.valid.wide)
    input.cov.valid.wide = cbind(input.cov.valid.wide, miss.col.matrix)

    input.cov.valid = input.cov.valid.wide
    input.cov.valid.lower = input.cov.valid[lower.tri(input.cov.valid)]; input.cov.valid.upper = input.cov.valid[upper.tri(input.cov.valid)]
    if(all(is.na(input.cov.valid.lower))){
      input.cov.valid[lower.tri(input.cov.valid)] = input.cov.valid[upper.tri(input.cov.valid)]
    }else{
      if(all(is.na(input.cov.valid.upper))){
        input.cov.valid[upper.tri(input.cov.valid)] = input.cov.valid[lower.tri(input.cov.valid)]
      }
    }
    input.cov.valid[is.na(input.cov.valid)] = 0
    message(paste0('\nInput long format data, transformed to wide format covariance matrix (',
                   length(unique.node),' unique nodes).'))
  }
  ### Check user's input
  if(!is.null(codify.feature) | !is.null(cuisearch.feature)){
    KOMAP.est.check(input.cov.train, target.code, target.cui, nm.utl,
                    codify.feature, cuisearch.feature)
  }else{
    KOMAP.est.check.part(input.cov.train, target.code, target.cui, nm.utl)
  }
  out_main = KOMAP.est.corrupt(input.cov.train, input.cov.valid, target.code, target.cui, nm.disease,
                               nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, dict,
                               codify.feature, cuisearch.feature)
  message('\nFinish estimating coefficients.')
  out = out_main$lst
  method_nm = names(out)
  feat.out = unique(unlist(sapply(out, function(x){x['feat']})))
  out_return = c(list(`est` = out_main))

  if(eval.sim){
    KOMAP.sim_auc.check(out, feat.out, mu0, mu1, var0, var1, prev_Y)
    out.sim = KOMAP.sim_auc(out, mu0, mu1, var0, var1, prev_Y, B = B)
    out_return = c(out_return, `sim_eval` = list(out.sim))
    message('Finish estimating AUC.')
  }

  if(pred){
    KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
    pred.prob = KOMAP.pred.corrupt(out, target.code, dat.part, nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, nm.id)
    out_return = c(out_return, `pred_prob` = list(pred.prob))
    message('Finish predicting scores.')
  }

  if(eval.real){
    if(pred){
      gold.label = dat.part[,c(nm.id, nm.y, nm.pi)]
      gold.label = stats::na.omit(gold.label)
      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return,
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }else{
      KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
      pred.prob = KOMAP.pred.corrupt(out, target.code, dat.part, nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, nm.id)
      gold.label = dat.part[,c(nm.id, nm.y, nm.pi)]
      gold.label = stats::na.omit(gold.label)
      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return, `pred_prob` = list(pred.prob),
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }
  }
  options(warn = oldw)
  return(out_return)
}


KOMAP.est.corrupt <- function(input.cov.train, input.cov.valid, target.code, target.cui, nm.disease,
                              nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, dict,
                              codify.feature, cuisearch.feature){
  out.all = c()
  parent.code0 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+')
  parent.code1 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{1}')
  parent.code2 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{2}')
  if(!is.na(parent.code2)){
    idd = which(!rownames(input.cov.train) %in% c(parent.code0, parent.code1))
    input.cov.train = input.cov.train[idd, idd]
    idd = which(!rownames(input.cov.valid) %in% c(parent.code0, parent.code1))
    input.cov.valid = input.cov.valid[idd, idd]
  }else{
    if(!is.na(parent.code1)){
      idd = which(!rownames(input.cov.train) %in% c(parent.code0))
      input.cov.train = input.cov.train[idd, idd]
      idd = which(!rownames(input.cov.valid) %in% c(parent.code0))
      input.cov.valid = input.cov.valid[idd, idd]
    }
  }

  if(is.null(codify.feature) & is.null(cuisearch.feature)){
    cuisearch.feature.new = codify.feature.new = setdiff(colnames(input.cov.train), c(nm.utl, nm.multi))
  }else{
    if(is.null(codify.feature)){
      codify.feature.new = target.code
      cuisearch.feature.new = cuisearch.feature
    }else{
      if(is.null(cuisearch.feature)){
        cuisearch.feature.new = target.cui
        codify.feature.new = codify.feature
      }else{
        cuisearch.feature.new = cuisearch.feature
        codify.feature.new = codify.feature
      }
    }
  }
  cuisearch.feature = unique(c(nm.corrupt.cui, cuisearch.feature))
  codify.feature = unique(c(nm.corrupt.code, codify.feature))
  cuisearch.feature.new = unique(c(nm.corrupt.cui, cuisearch.feature.new))
  codify.feature.new = unique(c(nm.corrupt.code, codify.feature.new))

  out = gen.KOMAP.est.table.corrupt(input.cov.train, input.cov.valid, nm.disease, nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, target.code, target.cui, dict,
                                    codify.feature = codify.feature, cuisearch.feature = cuisearch.feature,
                                    codify.feature.new = codify.feature.new, cuisearch.feature.new = cuisearch.feature.new)
  out.df = sapply(1:length(out), function(i){
    a = data.frame(`disease` = target.code,
                   `method` = names(out)[i],
                   `target` = paste0(out[[i]]$target, collapse = ', '),
                   `feat` = out[[i]]$beta$feat,
                   `coeff` = out[[i]]$beta$theta)
    return(a)
  }, simplify = FALSE)
  out.re = data.table::rbindlist(out.df)
  # out.re = out.re[out.re$method %in% str_remove(input$komap_feat,"combine\\_"), ]
  out.all = rbind(out.all, out.re)
  if(!is.null(dict)){
    out.all$desc = dict[match(out.all$feat, dict[,1]),2]
    out.all = out.all[,c('disease', 'method', 'target', 'feat', 'desc', 'coeff')]
    out.all$coeff = as.numeric(out.all$coeff)
    out.all = out.all[order(out.all$coeff, decreasing = TRUE), ]
    out.all$desc[out.all$feat == nm.utl] = 'Healthcare Utility'
  }else{
    out.all$desc = NA
    out.all = out.all[,c('disease', 'method', 'target', 'feat', 'desc', 'coeff')]
    out.all$coeff = as.numeric(out.all$coeff)
    out.all = out.all[order(out.all$coeff, decreasing = TRUE), ]
    out.all$desc[out.all$feat == nm.utl] = 'Healthcare Utility'
  }
  out.all = out.all %>% dplyr::arrange(.data$disease,.data$ method, -abs(.data$coeff))
  return(list(`long_df` = out.all,
              `lst` = out))
}


gen.KOMAP.est.table.corrupt <- function(input.cov.train, input.cov.valid, nm.disease, nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, target.code, target.cui, dict,
                                        codify.feature, cuisearch.feature,codify.feature.new, cuisearch.feature.new){
  if(is.null(target.code) & is.null(target.cui)){
    warning("You must at least specify one target (target.code or target.cui)!")
    return(0)
  }
  alpha.glmnent = 0.15
  ## By default: input.cov = XTX/N, X=(1,X_{sur},X_{komap},X_{u})

  colnames(input.cov.train)[stringr::str_detect(colnames(input.cov.train), '^CCS-PCS')] =
    stringr::str_replace(colnames(input.cov.train)[stringr::str_detect(colnames(input.cov.train), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')
  rownames(input.cov.train)[stringr::str_detect(rownames(input.cov.train), '^CCS-PCS')] =
    stringr::str_replace(rownames(input.cov.train)[stringr::str_detect(rownames(input.cov.train), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')

  colnames(input.cov.valid)[stringr::str_detect(colnames(input.cov.valid), '^CCS-PCS')] =
    stringr::str_replace(colnames(input.cov.valid)[stringr::str_detect(colnames(input.cov.valid), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')
  rownames(input.cov.valid)[stringr::str_detect(rownames(input.cov.valid), '^CCS-PCS')] =
    stringr::str_replace(rownames(input.cov.valid)[stringr::str_detect(rownames(input.cov.valid), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')

  nm.others = colnames(input.cov.train)
  nm.others = nm.others[!nm.others %in% c(target.code, target.cui, nm.utl)]
  all.nm = c(target.code, target.cui, nm.others, nm.utl)
  if(!is.null(nm.multi)){
    all.nm = c(all.nm, nm.multi)
  }
  feat.cov.train = input.cov.train[all.nm, all.nm]
  feat.cov.valid = input.cov.valid[all.nm, all.nm]
  nm.feat.all = sort(colnames(feat.cov.train))
  nm.cui = nm.feat.all[stringr::str_detect(nm.feat.all, "^C[0-9]{7}")]
  nm.code = setdiff(nm.feat.all, c(nm.cui, nm.utl))

  #### Both provide target code and target cui
  if(!is.null(target.code) & !is.null(target.cui)){
    nm.code.filter = codify.feature.new
    nm.cui.filter.final = cuisearch.feature.new

    nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov.train))
    nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov.train))

    if(is.null(cuisearch.feature) & is.null(codify.feature)){
      out = c()
      # main ICD + keser
      method =  list(`feat` = unique(c(nm.code.filter, target.code)),
                     `target` = target.code)
      out = c(out, `mainICD + allfeature` = list(method))


      # main ICDNLP + keser + NLP
      method = list(`feat` = unique(c(nm.code.filter, nm.cui.filter.final, target.code, target.cui)),
                    `target` = c(target.code, target.cui))
      out = c(out, `mainICDNLP + allfeature` = list(method))
    }else{
      out = c()
      # main ICD + keser
      method =  list(`feat` = unique(c(nm.code.filter, target.code)),
                     `target` = target.code)
      out = c(out, `mainICD + codify` = list(method))


      # main ICDNLP + keser + NLP
      method = list(`feat` = unique(c(nm.code.filter, nm.cui.filter.final, target.code, target.cui)),
                    `target` = c(target.code, target.cui))
      out = c(out, `mainICDNLP + codify & NLP` = list(method))
    }
  }else{
    if(!is.null(target.code)){
      nm.code.filter = codify.feature.new
      nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov.train))
      if(is.null(cuisearch.feature) & is.null(codify.feature)){
        out = c()
        method =  list(`feat` = c(nm.code.filter, target.code),
                       `target` = target.code)
        out = c(out, `mainICD + allfeature` = list(method))
      }else{
        out = c()
        # main ICD + codify
        method =  list(`feat` = c(nm.code.filter, target.code),
                       `target` = target.code)
        out = c(out, `mainICD + codify` = list(method))
      }
    }else{
      if(!is.null(target.cui)){
        nm.cui.filter.final = cuisearch.feature.new
        nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov.train))

        if(is.null(cuisearch.feature) & is.null(codify.feature)){
          out = c()
          # main NLP + NLP final weight
          method = list(`feat` = unique(c(nm.cui.filter.final, target.cui, target.code)),
                        `target` = target.cui)
          out = c(out, `mainNLP + allfeature` = list(method))
        }else{
          out = c()
          # main NLP + NLP final weight
          method = list(`feat` = unique(c(nm.cui.filter.final, target.cui, target.code)),
                        `target` = target.cui)
          out = c(out, `mainNLP + NLP_final` = list(method))
        }
      }
    }
  }

  for(i in 1:length(out)){
    method = out[[i]]
    plot_data = c()
    feat = method$feat; target = method$target
    if(length(target) == 1){

      ## do we need constant or not??
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      if(is.null(nm.multi)){
        all.nm = c(target, setdiff(feat, target), nm.utl)
      }else{
        all.nm =  c(target, setdiff(feat, target), nm.utl, nm.multi)
      }

      feat.cov.part = feat.cov.train[all.nm, all.nm]
      feat.cov.part.valid = feat.cov.valid[all.nm, all.nm]

      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      U.valid = svd(feat.cov.part.valid)
      U.valid = t(U.valid$u %*% sqrt(diag(U.valid$d)))
      colnames(U) = rownames(U) = colnames(U.valid) = rownames(U.valid) = colnames(feat.cov.part)

      # U = U[!rownames(U) %in% nm.corrupt.code, ]
      #! reg1 = stats::lm(U[, target] ~ 0 + U[, 1] + U[, nm.utl])
      reg1 = stats::lm(U[, target] ~ 0 + U[, nm.utl])
      U_new = U; U_new[, target] = reg1$residuals
      # reg1_corrupt = stats::lm(U[, nm.corrupt.code] ~ 0 + U[, nm.utl])
      # U_new[, nm.corrupt.code] = reg1_corrupt$residuals
      U_new[, nm.corrupt.code] = U_new[, nm.corrupt.code] - reg1$coefficients * U_new[, nm.utl]
      cor(U_new[, target], U_new[, nm.corrupt.code])

      U.valid[, target] = U.valid[, target] - reg1$coefficients * U.valid[, nm.utl]
      U.valid[, nm.corrupt.code] = U.valid[, nm.corrupt.code] - reg1$coefficients * U.valid[, nm.utl]
      cor(U.valid[, target], U.valid[, nm.corrupt.code])

      alpha = reg1$coefficients
      n_komap = length(setdiff(feat, c(nm.corrupt.code, target)))
      alpha_ma = cbind(c(1, rep(0, n_komap), -alpha),
                       rbind(matrix(0, 1, n_komap + length(nm.utl)),
                             diag(1, nrow = n_komap + length(nm.utl))))
      colnames(alpha_ma) = c(target, setdiff(feat, c(nm.corrupt.code, target)), nm.utl)

      if(!is.null(nm.multi)){
        all.nm.multi = c(target, setdiff(feat, target), nm.utl, nm.multi)
        alpha.site = c()
        for(j in 1:(length(all.nm)-1)){
          target.j = all.nm[j]
          reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.multi])
          U_new[, target.j] = reg1$residuals
          alpha.site = c(alpha.site, reg1$coefficients)
        }
        alpha_ma = cbind(c(1, rep(0, n_komap), -alpha, 0),
                         rbind(matrix(0, 1, length(all.nm) - length(target)),
                               diag(1, nrow = length(all.nm) - length(target))))
        alpha.site_ma = cbind(rbind(diag(1, nrow = length(all.nm) - length(nm.multi)), -t(alpha.site)),
                              c(rep(0, length(all.nm) - length(nm.multi)), 1))
        alpha_ma = alpha_ma %*% alpha.site_ma
      }



      #! U_new = U_new[,-1]
      # U_new = U_new[c(target, setdiff(feat, target), nm.utl),c(target, setdiff(feat, target), nm.utl)]
      Y = U_new[, target]
      id_target = which(colnames(U_new) == target)
      id_target_corrupt = which(colnames(U_new) == nm.corrupt.code)
      set.seed(10101)
      cv.fit <- glmnet::cv.glmnet(U_new[, -id_target], Y, intercept = F, alpha = alpha.glmnent, standardize = F)
      lambda_vec = cv.fit$lambda
      mse_vec = sapply(lambda_vec, function(lambda){
        model.fit <- glmnet::glmnet(U_new[, -id_target_corrupt], Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                                    lambda = lambda)
        # predict.valid.fit <- predict(model.fit, newx = U.valid[, -id_target])
        junk = U.valid[, -c(id_target)]
        colnames(junk)[colnames(junk) == nm.corrupt.code] = target
        coef.beta = as.matrix(model.fit$beta)
        predict.valid.fit <- junk %*% coef.beta[colnames(junk), ]
        mse.fit = mean((U.valid[, id_target] - predict.valid.fit)^2)
        return(mse.fit)
      })
      # plot(log(lambda_vec), mse_vec, type = 'l', main = paste(nm.disease, ' Corrupt ICDonly, ', target))
      # abline(v = log(lambda_vec[which.min(mse_vec)]), col = 'red')

      plot_data = c(plot_data, list(lambda = lambda_vec, mse = mse_vec))
      model.fit <- glmnet::glmnet(U_new[, -id_target_corrupt], Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                                  lambda = lambda_vec[which.min(mse_vec)])
      b.all <- as.vector(model.fit$beta)
      # b.all.ori <- solve(XTX + W) %*% XTY
      # score = U_new[, -id_target] %*% b.all

      rownames(model.fit$beta)[which(rownames(model.fit$beta) == nm.corrupt.code)] = target
      theta = alpha_ma[,rownames(model.fit$beta)] %*% model.fit$beta
      beta.all <- data.frame(`feat` = rownames(model.fit$beta), `theta` = as.vector(theta))
      # beta.all$beta = NA; beta.all$beta[match(colnames(XTX), beta.all$feat)] = b.all
      method$beta = beta.all
      method$plot_data = plot_data
      # method$est_score = score
      out[[i]] = method
    }else{
      b.all = score = alpha = c()
      nm.corrupt.vec = c(nm.corrupt.code, nm.corrupt.cui)
      # ##!! first together regress out utl for main codes and then estimate beta together!!
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      if(is.null(nm.multi)){
        all.nm = c(target, setdiff(feat, target), nm.utl)
      }else{
        all.nm =  c(target, setdiff(feat, target), nm.utl, nm.multi)
      }

      feat.cov.part = feat.cov.train[all.nm, all.nm]
      feat.cov.part.valid = feat.cov.valid[all.nm, all.nm]

      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      U.valid = svd(feat.cov.part.valid)
      U.valid = t(U.valid$u %*% sqrt(diag(U.valid$d)))
      colnames(U) = rownames(U) = colnames(U.valid) = rownames(U.valid) = colnames(feat.cov.part)

      U_new = U
      for(j in 1:length(target)){
        target.j = target[j]
        reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.utl])
        U_new[, target.j] = reg1$residuals
        nm.corrupt = nm.corrupt.vec[j]

        # reg1_corrupt = stats::lm(U[, nm.corrupt] ~ 0 + U[, nm.utl])
        # U_new[, nm.corrupt] = reg1_corrupt$residuals
        U_new[, nm.corrupt] = U_new[, nm.corrupt] - reg1$coefficients * U_new[, nm.utl]
        cor(U_new[, target.j], U_new[, nm.corrupt])

        U.valid[, target.j] = U.valid[, target.j] - reg1$coefficients * U.valid[, nm.utl]
        U.valid[, nm.corrupt] = U.valid[, nm.corrupt] - reg1$coefficients * U.valid[, nm.utl]
        cor(U.valid[, target.j], U.valid[, nm.corrupt])

        alpha = cbind(alpha, reg1$coefficients)
      }
      n_komap = length(setdiff(feat, c(nm.corrupt.code, nm.corrupt.cui, target)))
      alpha_ma = cbind(c(1, 0, rep(0, n_komap), -alpha[, 1]),
                       c(0, 1, rep(0, n_komap), -alpha[, 2]),
                       rbind(matrix(0, 2, n_komap + length(nm.utl)),
                             diag(1, nrow = n_komap + length(nm.utl))))
      colnames(alpha_ma) = c(target, setdiff(feat, c(nm.corrupt.code, nm.corrupt.cui, target)), nm.utl)

      if(!is.null(nm.multi)){
        all.nm.multi = c(target, setdiff(feat, target), nm.utl, nm.multi)
        alpha.site = c()
        for(j in 1:(length(all.nm)-1)){
          target.j = all.nm[j]
          reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.multi])
          U_new[, target.j] = reg1$residuals
          alpha.site = c(alpha.site, reg1$coefficients)
        }
        alpha_ma = cbind(c(1, 0, rep(0, n_komap), -alpha[, 1], 0),
                         c(0, 1, rep(0, n_komap), -alpha[, 2], 0),
                         rbind(matrix(0, 2, length(all.nm) - length(target)),
                               diag(1, nrow = length(all.nm) - length(target))))

        alpha.site_ma = cbind(rbind(diag(1, nrow = length(all.nm) - length(nm.multi)), -t(alpha.site)),
                              c(rep(0, length(all.nm) - length(nm.multi)), 1))
        alpha_ma = alpha_ma %*% alpha.site_ma
      }


      for(j in 1:length(target)){
        target.j = target[j]
        Y = U_new[, target.j]
        id_target = which(colnames(U_new) == target.j)
        id_target_corrupt = which(colnames(U_new) == nm.corrupt.vec[j])
        id_elsetarget_corrupt = which(colnames(U_new) == nm.corrupt.vec[3-j])
        set.seed(10101)
        cv.fit <- glmnet::cv.glmnet(U_new[, -c(id_target_corrupt, id_elsetarget_corrupt)], Y,
                                    intercept = F, alpha = alpha.glmnent, standardize = F)

        lambda_vec = cv.fit$lambda
        mse_vec = sapply(lambda_vec, function(lambda){
          model.fit <- glmnet::glmnet(U_new[, -c(id_target_corrupt, id_elsetarget_corrupt)], Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                                      lambda = lambda)
          junk = U.valid[, -c(id_target, id_elsetarget_corrupt)]
          colnames(junk)[colnames(junk) == nm.corrupt.vec[j]] = target.j
          coef.beta = as.matrix(model.fit$beta)
          predict.valid.fit <- junk %*% coef.beta[colnames(junk), ]
          # predict.valid.fit <- predict(model.fit, newx = U.valid[, -c(id_target, id_elsetarget_corrupt)])
          mse.fit = mean((U.valid[, id_target] - predict.valid.fit)^2)
          return(mse.fit)
        })
        # plot(log(lambda_vec), mse_vec, type = 'l', main = paste(nm.disease, ' Corrupt ICDNLP, ', target.j))
        # abline(v = log(lambda_vec[which.min(mse_vec)]), col = 'red')

        plot_data = c(plot_data, list(lambda = lambda_vec, mse = mse_vec))
        model.fit <- glmnet::glmnet(U_new[, -c(id_target_corrupt, id_elsetarget_corrupt)], Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                                    lambda = lambda_vec[which.min(mse_vec)])

        # score0 = U_new[, -c(id_target, id_elsetarget_corrupt)] %*% model.fit$beta
        score0 = U_new[, -c(id_target_corrupt, id_elsetarget_corrupt)] %*% model.fit$beta
        rownames(model.fit$beta)[which(rownames(model.fit$beta) == nm.corrupt.vec[j])] = target.j
        b.all0 <- as.vector(model.fit$beta); names(b.all0) = rownames(model.fit$beta)
        # b.all0 = solve(XTX + W) %*% XTY
        b.all <- cbind(b.all, b.all0[match(names(b.all0), colnames(alpha_ma))])
        # score = cbind(score, score0[match(rownames(score0), colnames(alpha_ma))])
        score = cbind(score, score0)
      }

      pca.score = stats::princomp(score)
      gamma = pca.score$loadings[,1]

      theta = alpha_ma %*% b.all %*% gamma
      beta.all <- data.frame(`feat` = colnames(alpha_ma), `theta` = theta)
      # beta.all$beta_ICD = beta.all$beta_NLP = NA
      # beta.all$beta_ICD[match(rownames(b.all), beta.all$feat)] = b.all[,1]
      # beta.all$beta_NLP[match(rownames(b.all), beta.all$feat)] = b.all[,2]
      method$beta = beta.all
      method$plot_data = plot_data
      # method$est_score = U_new %*% b.all %*% gamma
      out[[i]] = method

    }
  }
  return(out)
}



#' @import mclust
KOMAP.pred.corrupt <- function(out, target.code, dat.part, nm.utl, nm.corrupt.code, nm.corrupt.cui, nm.multi, nm.id = 'patient_num'){
  pred.prob = data.frame(`patient_num` = dat.part[,nm.id])
  pred.cluster = data.frame(`patient_num` = dat.part[,nm.id])
  for(i in 1:length(out)){
    method = out[[i]]
    feat = method$beta$feat
    # feat = setdiff(feat, c(nm.corrupt.code, nm.corrupt.cui))
    # print(setdiff(feat,  colnames(dat.part)))
    feat = intersect(feat, colnames(dat.part))
    if(length(feat) == 1){
      dat.part.filter = data.frame(dat.part[, feat])
      colnames(dat.part.filter) = feat
    }else{
      dat.part.filter = dat.part[, feat]
    }
    dat.part.filter = as.data.frame(cbind(dat.part[,nm.utl], dat.part.filter))
    colnames(dat.part.filter)[1] = nm.utl
    if(!is.null(nm.multi)){
      dat.part.filter = as.data.frame(cbind(dat.part[,nm.multi], dat.part.filter))
      colnames(dat.part.filter)[1] = nm.multi
    }
    b.all = data.frame(`coeff` = method$beta$theta, `feat` = method$beta$feat)
    b.all = b.all[b.all$feat %in% feat, ]
    S.norm <- as.matrix(dat.part.filter[,b.all$feat]) %*% matrix(b.all$coeff, ncol=1)

    ## Fit gaussian mixture model on S.norm, we only use the "length(nm.logS.ori) = 1" case:
    fit = S.norm
    pred.prob = cbind(pred.prob, fit)
    junk = mclust::Mclust(S.norm, G = 2, verbose = FALSE)
    cor1 = cor(dat.part[, target.code], junk$classification, method = 'kendall')
    cor2 = cor(dat.part[, target.code], 3-junk$classification, method = 'kendall')
    # cluster_i = ifelse(cor1 > cor2, junk$classification - 1, 3 - junk$classification)
    if(cor1 > cor2){
      cluster_i = factor(junk$classification, levels = c(1, 2), labels = c('no disease', 'disease'))
    }else{
      cluster_i = factor(junk$classification, levels = c(1, 2), labels = c('disease', 'no disease'))
    }
    pred.cluster = cbind(pred.cluster, cluster_i)
  }
  colnames(pred.prob)[-1] = names(out)
  colnames(pred.cluster)[-1] = names(out)
  return(list(`pred.score` = stats::na.omit(pred.prob), `pred.cluster` = stats::na.omit(pred.cluster)))
}



KOMAP.eval <- function(pred.prob, gold.label, nm.pi = NULL, nm.y = 'Y', nm.id, method_nm){
  dat.merge = dplyr::left_join(gold.label, pred.prob$pred.score, by = nm.id)
  dat.merge = stats::na.omit(dat.merge)
  Y <- dat.merge[, nm.y]
  auc_table <- c()
  F_table <- c()
  prev_vec <- c()
  label_num_vec <- c()
  # Since the sampling of gold label set is not completely at random, we need to include weights:
  if(!is.null(nm.pi)){
    w <- 1 / dat.merge[,nm.pi]
  }else{
    dat.merge$pi = w <- rep(1/nrow(dat.merge), nrow(dat.merge))
  }
  prev_vec <- c(prev_vec, mean(Y))
  label_num_vec <- c(label_num_vec, length(Y))
  num_method <- length(method_nm)
  auc_vec <- rep(0, num_method)
  F_vec <- rep(0, num_method)
  roc_lst <- vector('list', num_method)

  for (t in 1:num_method){
    # AUC
    auc_vec[t] <- AUC(Y, as.vector(dat.merge[,method_nm[t]]), wgt=w)
    # ROC table
    roc_lst[[t]] <- ROC(Y, as.vector(dat.merge[,method_nm[t]]), wgti=w, seq = seq(.01,.99,by=1e-5))[-1,]
    # Maximum F-score
    F_score_all <- 2 / (1 / roc_lst[[t]][,4] + 1 / roc_lst[[t]][,5])
    F_vec[t] <- max(F_score_all)
  }
  return(data.frame(`method` = method_nm,
                    `auc` = auc_vec,
                    `F_score_max` = F_vec)
         # `F_score_max` = F_vec
  )
}




KOMAP.sim_auc <- function(out, mus0, mus1, vars0, vars1, prev_Y, B = 10000){
  if(all(!is.na(mus0) & !is.na(mus1) & !is.na(vars0) & !is.na(vars1) &
         !is.null(out))){
    feat.all = colnames(vars0)
    names(mus0) = names(mus1) = colnames(vars0)
    auc_sim = c()
    for(i in 1:length(out)){
      feat.id = which(out[[i]]$beta$feat %in% colnames(vars0))
      feat.i = out[[i]]$beta$feat[feat.id]
      theta = out[[i]]$beta$theta[feat.id]
      mus0_part = mus0[feat.i]
      mus1_part = mus1[feat.i]
      vars0_part = vars0[feat.i, feat.i]
      vars1_part = vars1[feat.i, feat.i]

      Y = stats::rbinom(B, size = 1, prob = prev_Y)
      X_score = rep(0, B)
      X_score[Y == 0] = MASS::mvrnorm(n = sum(Y==0), mu = mus0_part %*% theta,
                                      Sigma = t(theta) %*% vars0_part %*% theta)
      X_score[Y == 1] = MASS::mvrnorm(n = sum(Y==1), mu = mus1_part %*% theta,
                                      Sigma = t(theta) %*% vars1_part %*% theta)
      auc_sim <- c(auc_sim, AUC(Y, X_score))
    }
    out_sim_re = data.frame(`method` = names(out),
                            `auc` = auc_sim)
  }
  return(out_sim_re)
}
