#' Run komap main function
#'
#' @param input.cov A covariance matrix of the target disease with colnames and rownames equal to variable names.
#' @param is.wide If \code{TRUE}, \code{input.cov} is treated as a normal p by p covariance matrix. If \code{FALSE}, treat \code{input.cov} as in a long format with three columns (the first two indicating row and column names and the last one indicating covariance value). If only inputing the lower/upper triangle part, the function will automatically fill the other side assuming symmetric covariance matrix.
#' @param target.code Main phecode of the target disease.
#' @param target.cui Main NLP feature (CUI) of the target disease, can be NULL if NLP features are not available.
#' @param nm.utl Variable name of health utility score.
#' @param nm.multi Variable name indicating the site id. Default is NULL for the single site case.
#' @param dict Dictionary mapping feature id (the first column) to full description (the second column). Default is set to be NULL.
#' @param codify.feature A vector of codified features related to the target code. Can be generated by KESER or ONCE (Codisearch). If \code{NULL}, then use all features in \code{input.cov}.
#' @param nlp.feature A vector of NLP features related to the target code. Can be generated by ONCE (CUIsearch). If \code{NULL}, then use all features in \code{input.cov}.
#' @param pred If \code{TRUE}, predict disease scores for individual data.
#' @param eval.real If \code{TRUE}, evaluate model performance based on prediction of individual data with gold labels.
#' @param eval.sim If \code{TRUE}, evaluate model performance based on conditional covariance matrices, conditional mean vectors and prevalence of the target disease.
#' @param mu0 Conditional mean vector of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param mu1 Conditional mean vector of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same length and in the same feature order as \code{mu0}.
#' @param var0 Conditional covariance matrix of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param var1 Conditional covariance matrix of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same dimension and in the same feature order as \code{var0}.
#' @param prev_Y Prevalence of the target disease. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param B The number of samples to calculate simulated AUC, given the conditional Gaussian assumption. Default is 10000.
#' @param dat.part Patient-level data for prediction. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param nm.id Name of the patient id column in \code{dat.part} and \code{gold.label}. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param nm.pi The column name of sample probability in \code{gold.label} if individuals in \code{gold.label} are generated with different probabilities. Default is \code{NULL}, meaning a uniform sample distribution.
#' @param nm.y The column name of labels in \code{gold.label}. Must be provided if \code{eval.real}=\code{TRUE}.
#' @returns A list containing estimation and/or prediction and/or evaluation results by running KOMAP.
#' @examples
#' codify.feature <- codify_RA$Variable[codify_RA$high_confidence_level == 1]
#' nlp.feature <- cui_RA$cui[cui_RA$high_confidence_level == 1]
#' input.cov <- cov_RA
#' target.code <- 'PheCode:714.1'
#' target.cui <- 'C0003873'
#' nm.utl <- 'utl'
#' nm.pi <- 'pi'
#' nm.id <- 'patient_num'
#' nm.y <- 'Y'
#' dat.part <- dat_part
#'
#' out <- KOMAP(input.cov, is.wide = TRUE, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
#'                codify.feature, nlp.feature,
#'                pred = TRUE, eval.real = TRUE, eval.sim = FALSE,
#'                dat.part = dat.part, nm.id = nm.id, nm.pi = nm.pi, nm.y = nm.y)
#' @export
KOMAP <- function(input.cov, is.wide = TRUE, target.code, target.cui, nm.utl, nm.multi = NULL, dict = NULL,
                  codify.feature = NULL, nlp.feature = NULL,
                  pred = FALSE, eval.real = FALSE, eval.sim = TRUE,
                  mu0 = NULL, mu1 = NULL, var0 = NULL, var1 = NULL, prev_Y = NULL, B = 10000,
                  dat.part = NULL, nm.id = NULL, nm.pi = NULL, nm.y = NULL){
  oldw <- getOption("warn")
  options(warn = -1)
  if(is.null(nlp.feature)){
    cuisearch.feature = NULL
  }else{
    cuisearch.feature = nlp.feature
  }
  if(!is.wide){
    input.cov = as.data.frame(input.cov)
    unique.node = unique(c(input.cov[,1], input.cov[,2]))
    colnames(input.cov) = c('from', 'to', 'cov')

    input.cov.wide = stats::reshape(as.data.frame(input.cov), idvar = "from", timevar = "to",
                                    direction = "wide")
    rownames(input.cov.wide) = input.cov.wide$from; input.cov.wide$from = NULL
    colnames(input.cov.wide) = stringr::str_remove(colnames(input.cov.wide), '^cov\\.')
    miss.row = setdiff(unique.node, rownames(input.cov.wide))
    miss.row.matrix = matrix(NA, nrow = length(miss.row), ncol = ncol(input.cov.wide))
    rownames(miss.row.matrix) = miss.row; colnames(miss.row.matrix) = colnames(input.cov.wide)
    input.cov.wide = rbind(input.cov.wide, miss.row.matrix)

    miss.col = setdiff(unique.node, colnames(input.cov.wide))
    miss.col.matrix = matrix(NA, nrow = nrow(input.cov.wide), ncol = length(miss.col))
    colnames(miss.col.matrix) = miss.col; rownames(miss.col.matrix) = rownames(input.cov.wide)
    input.cov.wide = cbind(input.cov.wide, miss.col.matrix)

    input.cov = input.cov.wide
    input.cov.lower = input.cov[lower.tri(input.cov)]; input.cov.upper = input.cov[upper.tri(input.cov)]
    if(all(is.na(input.cov.lower))){
      input.cov[lower.tri(input.cov)] = input.cov[upper.tri(input.cov)]
    }else{
      if(all(is.na(input.cov.upper))){
        input.cov[upper.tri(input.cov)] = input.cov[lower.tri(input.cov)]
      }
    }
    input.cov[is.na(input.cov)] = 0
    message(paste0('\nInput long format data, transformed to wide format covariance matrix (',
                   length(unique.node),' unique nodes).'))
  }
  colnames(input.cov) = rownames(input.cov)
  ### Check user's input
  if(!is.null(codify.feature) | !is.null(cuisearch.feature)){
    KOMAP.est.check(input.cov, target.code, target.cui, nm.utl,
                    codify.feature, cuisearch.feature)
  }else{
    KOMAP.est.check.part(input.cov, target.code, target.cui, nm.utl)
  }
  out_main = KOMAP.est(input.cov, target.code, target.cui, nm.utl, nm.multi, dict,
                       codify.feature, cuisearch.feature)
  message('\nFinish estimating coefficients.')
  out = out_main$lst
  method_nm = names(out)
  feat.out = unique(unlist(sapply(out, function(x){x['feat']})))
  out_return = c(list(`est` = out_main))

  if(eval.sim){
    KOMAP.sim_auc.check(out, feat.out, mu0, mu1, var0, var1, prev_Y)
    out.sim = KOMAP.sim_auc(out, mu0, mu1, var0, var1, prev_Y, B = B)
    out_return = c(out_return, `sim_eval` = list(out.sim))
    message('Finish estimating AUC.')
  }

  if(pred){
    KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
    pred.prob = KOMAP.pred(out, dat.part, nm.utl, nm.multi, nm.id)
    out_return = c(out_return, `pred_prob` = list(pred.prob))
    message('Finish predicting scores.')
  }

  if(eval.real){
    if(pred){
      gold.label = dat.part[,c(nm.id, nm.y, nm.pi)]
      gold.label = stats::na.omit(gold.label)
      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return,
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }else{
      KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
      pred.prob = KOMAP.pred(out, dat.part, nm.utl, nm.multi, nm.id)
      gold.label = dat.part[,c(nm.id, nm.y, nm.pi)]
      gold.label = stats::na.omit(gold.label)
      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return, `pred_prob` = list(pred.prob),
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }
  }
  options(warn = oldw)
  return(out_return)
}


KOMAP.est <- function(input.cov, target.code, target.cui, nm.utl, nm.multi, dict,
                      codify.feature, cuisearch.feature){
  out.all = c()
  parent.code0 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+')
  parent.code1 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{1}')
  parent.code2 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{2}')
  if(!is.na(parent.code2)){
    idd = which(!rownames(input.cov) %in% c(parent.code0, parent.code1))
    input.cov = input.cov[idd, idd]
  }else{
    if(!is.na(parent.code1)){
      idd = which(!rownames(input.cov) %in% c(parent.code0))
      input.cov = input.cov[idd, idd]
    }
  }

  if(is.null(codify.feature) & is.null(cuisearch.feature)){
    cuisearch.feature.new = codify.feature.new = setdiff(colnames(input.cov), c(nm.utl, nm.multi))
  }else{
    if(is.null(codify.feature)){
      codify.feature.new = target.code
      cuisearch.feature.new = cuisearch.feature
    }else{
      if(is.null(cuisearch.feature)){
        cuisearch.feature.new = target.cui
        codify.feature.new = codify.feature
      }else{
        cuisearch.feature.new = cuisearch.feature
        codify.feature.new = codify.feature
      }
    }
  }
  out = gen.KOMAP.est.table(input.cov, nm.utl, nm.multi, target.code, target.cui, dict,
                            codify.feature = codify.feature, cuisearch.feature = cuisearch.feature,
                            codify.feature.new = codify.feature.new, cuisearch.feature.new = cuisearch.feature.new)
  out.df = sapply(1:length(out), function(i){
    a = data.frame(`disease` = target.code,
                   `method` = names(out)[i],
                   `target` = paste0(out[[i]]$target, collapse = ', '),
                   `feat` = out[[i]]$beta$feat,
                   `coeff` = out[[i]]$beta$theta)
    return(a)
  }, simplify = FALSE)
  out.re = data.table::rbindlist(out.df)
  # out.re = out.re[out.re$method %in% str_remove(input$komap_feat,"combine\\_"), ]
  out.all = rbind(out.all, out.re)
  if(!is.null(dict)){
    out.all$desc = dict[match(out.all$feat, dict[,1]),2]
    out.all = out.all[,c('disease', 'method', 'target', 'feat', 'desc', 'coeff')]
    out.all$coeff = as.numeric(out.all$coeff)
    out.all = out.all[order(out.all$coeff, decreasing = TRUE), ]
    out.all$desc[out.all$feat == nm.utl] = 'Healthcare Utility'
  }else{
    out.all$desc = NA
    out.all = out.all[,c('disease', 'method', 'target', 'feat', 'desc', 'coeff')]
    out.all$coeff = as.numeric(out.all$coeff)
    out.all = out.all[order(out.all$coeff, decreasing = TRUE), ]
    out.all$desc[out.all$feat == nm.utl] = 'Healthcare Utility'
  }
  out.all = out.all %>% dplyr::arrange(disease, method, -abs(coeff))
  return(list(`long_df` = out.all,
              `lst` = out))
}


gen.KOMAP.est.table <- function(input.cov, nm.utl, nm.multi, target.code, target.cui, dict,
                                codify.feature, cuisearch.feature,codify.feature.new, cuisearch.feature.new){
  if(is.null(target.code) & is.null(target.cui)){
    warning("You must at least specify one target (target.code or target.cui)!")
    return(0)
  }
  alpha.glmnent = 0.15
  ## By default: input.cov = XTX/N, X=(1,X_{sur},X_{komap},X_{u})

  colnames(input.cov)[stringr::str_detect(colnames(input.cov), '^CCS-PCS')] =
    stringr::str_replace(colnames(input.cov)[stringr::str_detect(colnames(input.cov), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')
  rownames(input.cov)[stringr::str_detect(rownames(input.cov), '^CCS-PCS')] =
    stringr::str_replace(rownames(input.cov)[stringr::str_detect(rownames(input.cov), '^CCS-PCS')],
                         '^CCS-PCS', 'CCS')

  nm.others = colnames(input.cov)
  nm.others = nm.others[!nm.others %in% c(target.code, target.cui, nm.utl)]
  all.nm = c(target.code, target.cui, nm.others, nm.utl)
  if(!is.null(nm.multi)){
    all.nm = c(all.nm, nm.multi)
  }
  feat.cov = input.cov[all.nm, all.nm]
  nm.feat.all = sort(colnames(feat.cov))
  nm.cui = nm.feat.all[stringr::str_detect(nm.feat.all, "^C[0-9]{7}")]
  nm.code = setdiff(nm.feat.all, c(nm.cui, nm.utl))

  #### Both provide target code and target cui
  if(!is.null(target.code) & !is.null(target.cui)){
    nm.code.filter = codify.feature.new
    nm.cui.filter.final = cuisearch.feature.new

    nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov))
    nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov))

    if(is.null(cuisearch.feature) & is.null(codify.feature)){
      out = c()
      # main ICD + keser
      method =  list(`feat` = unique(c(nm.code.filter, target.code)),
                     `target` = target.code)
      out = c(out, `mainICD + allfeature` = list(method))


      # main ICDNLP + keser + NLP
      method = list(`feat` = unique(c(nm.code.filter, nm.cui.filter.final, target.code, target.cui)),
                    `target` = c(target.code, target.cui))
      out = c(out, `mainICDNLP + allfeature` = list(method))
    }else{
      out = c()
      # main ICD + keser
      method =  list(`feat` = unique(c(nm.code.filter, target.code)),
                     `target` = target.code)
      out = c(out, `mainICD + codify` = list(method))


      # main ICDNLP + keser + NLP
      method = list(`feat` = unique(c(nm.code.filter, nm.cui.filter.final, target.code, target.cui)),
                    `target` = c(target.code, target.cui))
      out = c(out, `mainICDNLP + codify & NLP` = list(method))
    }
  }else{
    if(!is.null(target.code)){
      nm.code.filter = codify.feature.new
      nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov))
      if(is.null(cuisearch.feature) & is.null(codify.feature)){
        out = c()
        method =  list(`feat` = c(nm.code.filter, target.code),
                       `target` = target.code)
        out = c(out, `mainICD + allfeature` = list(method))
      }else{
        out = c()
        # main ICD + codify
        method =  list(`feat` = c(nm.code.filter, target.code),
                       `target` = target.code)
        out = c(out, `mainICD + codify` = list(method))
      }
    }else{
      if(!is.null(target.cui)){
        nm.cui.filter.final = cuisearch.feature.new
        nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov))

        if(is.null(cuisearch.feature) & is.null(codify.feature)){
          out = c()
          # main NLP + NLP final weight
          method = list(`feat` = unique(c(nm.cui.filter.final, target.cui, target.code)),
                        `target` = target.cui)
          out = c(out, `mainNLP + allfeature` = list(method))
        }else{
          out = c()
          # main NLP + NLP final weight
          method = list(`feat` = unique(c(nm.cui.filter.final, target.cui, target.code)),
                        `target` = target.cui)
          out = c(out, `mainNLP + NLP_final` = list(method))
        }
      }
    }
  }

  for(i in 1:length(out)){
    method = out[[i]]
    feat = method$feat; target = method$target
    if(length(target) == 1){

      ## do we need constant or not??
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      if(is.null(nm.multi)){
        all.nm = c(target, setdiff(feat, target), nm.utl)
      }else{
        all.nm =  c(target, setdiff(feat, target), nm.utl, nm.multi)
      }

      feat.cov.part = feat.cov[all.nm, all.nm]

      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      colnames(U) = rownames(U) = colnames(feat.cov.part)
      #! reg1 = stats::lm(U[, target] ~ 0 + U[, 1] + U[, nm.utl])
      reg1 = stats::lm(U[, target] ~ 0 + U[, nm.utl])
      U_new = U; U_new[, target] = reg1$residuals
      alpha = reg1$coefficients
      n_komap = length(setdiff(feat, target))
      alpha_ma = cbind(c(1, rep(0, n_komap), -alpha),
                       rbind(matrix(0, 1, n_komap + length(nm.utl)),
                             diag(1, nrow = n_komap + length(nm.utl))))

      if(!is.null(nm.multi)){
        all.nm.multi = c(target, setdiff(feat, target), nm.utl, nm.multi)
        alpha.site = c()
        for(j in 1:(length(all.nm)-1)){
          target.j = all.nm[j]
          reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.multi])
          U_new[, target.j] = reg1$residuals
          alpha.site = c(alpha.site, reg1$coefficients)
        }
        alpha_ma = cbind(c(1, rep(0, n_komap), -alpha, 0),
                         rbind(matrix(0, 1, length(all.nm) - length(target)),
                               diag(1, nrow = length(all.nm) - length(target))))
        alpha.site_ma = cbind(rbind(diag(1, nrow = length(all.nm) - length(nm.multi)), -t(alpha.site)),
                              c(rep(0, length(all.nm) - length(nm.multi)), 1))
        alpha_ma = alpha_ma %*% alpha.site_ma
      }



      #! U_new = U_new[,-1]
      # U_new = U_new[c(target, setdiff(feat, target), nm.utl),c(target, setdiff(feat, target), nm.utl)]
      Y = U_new[, target]
      XTX <- t(U_new) %*% U_new
      XTY <- t(U_new) %*% Y
      #!!!ask molei W_vec <- diag(XTX) * lambda
      # W_vec <- rep(lambda, nrow(XTX))
      W_vec <- diag(XTX)
      W <- diag(W_vec)

      if (ncol(W) == 0){
        W <- 0
      }
      set.seed(10101)
      cv.fit <- glmnet::cv.glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = F)
      model.fit <- glmnet::glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                                  lambda = cv.fit$lambda.min)
      b.all <- as.vector(model.fit$beta)
      # b.all.ori <- solve(XTX + W) %*% XTY
      score = U_new %*% b.all

      theta = alpha_ma %*% b.all
      beta.all <- data.frame(`feat` = rownames(U), `theta` = theta)
      # beta.all$beta = NA; beta.all$beta[match(colnames(XTX), beta.all$feat)] = b.all
      method$beta = beta.all
      # method$est_score = score
      out[[i]] = method
    }else{
      b.all = score = alpha = c()

      # ##!! first together regress out utl for main codes and then estimate beta together!!
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      if(is.null(nm.multi)){
        all.nm = c(target, setdiff(feat, target), nm.utl)
      }else{
        all.nm =  c(target, setdiff(feat, target), nm.utl, nm.multi)
      }

      feat.cov.part = feat.cov[all.nm, all.nm]
      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      colnames(U) = rownames(U) = colnames(feat.cov.part)
      #! U_new = U[,-1]
      U_new = U
      for(j in 1:length(target)){
        target.j = target[j]
        reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.utl])
        U_new[, target.j] = reg1$residuals
        alpha = cbind(alpha, reg1$coefficients)
      }
      n_komap = length(setdiff(feat, target))
      alpha_ma = cbind(c(1, 0, rep(0, n_komap), -alpha[, 1]),
                       c(0, 1, rep(0, n_komap), -alpha[, 2]),
                       rbind(matrix(0, 2, n_komap + length(nm.utl)),
                             diag(1, nrow = n_komap + length(nm.utl))))

      if(!is.null(nm.multi)){
        all.nm.multi = c(target, setdiff(feat, target), nm.utl, nm.multi)
        alpha.site = c()
        for(j in 1:(length(all.nm)-1)){
          target.j = all.nm[j]
          reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.multi])
          U_new[, target.j] = reg1$residuals
          alpha.site = c(alpha.site, reg1$coefficients)
        }
        alpha_ma = cbind(c(1, 0, rep(0, n_komap), -alpha[, 1], 0),
                         c(0, 1, rep(0, n_komap), -alpha[, 2], 0),
                         rbind(matrix(0, 2, length(all.nm) - length(target)),
                               diag(1, nrow = length(all.nm) - length(target))))

        alpha.site_ma = cbind(rbind(diag(1, nrow = length(all.nm) - length(nm.multi)), -t(alpha.site)),
                              c(rep(0, length(all.nm) - length(nm.multi)), 1))
        alpha_ma = alpha_ma %*% alpha.site_ma
      }


      for(j in 1:length(target)){
        target.j = target[j]
        Y = U_new[, target.j]
        XTX <- t(U_new) %*% U_new
        XTY <- t(U_new) %*% Y
        #!!!! W_vec <- diag(XTX) * lambda
        # W_vec <- rep(lambda, nrow(XTX))
        W_vec <- diag(XTX)
        W <- diag(W_vec)

        if (ncol(W) == 0){
          W <- 0
        }
        set.seed(10101)
        cv.fit <- glmnet::cv.glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = FALSE)
        model.fit <- glmnet::glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = FALSE,
                                    lambda = cv.fit$lambda.min)
        b.all0 <- as.vector(model.fit$beta)
        # b.all0 = solve(XTX + W) %*% XTY
        b.all <- cbind(b.all, b.all0)
        score = cbind(score, as.matrix(U_new %*% b.all0, ncol = 1))
      }

      pca.score = stats::princomp(U %*% alpha_ma %*% b.all)
      gamma = pca.score$loadings[,1]

      theta = alpha_ma %*% b.all %*% gamma
      beta.all <- data.frame(`feat` = rownames(U), `theta` = theta)
      # beta.all$beta_ICD = beta.all$beta_NLP = NA
      # beta.all$beta_ICD[match(rownames(b.all), beta.all$feat)] = b.all[,1]
      # beta.all$beta_NLP[match(rownames(b.all), beta.all$feat)] = b.all[,2]
      method$beta = beta.all
      # method$est_score = U_new %*% b.all %*% gamma
      out[[i]] = method
    }
  }
  return(out)
}




KOMAP.pred <- function(out, dat.part, nm.utl, nm.multi, nm.id = 'patient_num'){
  pred.prob = data.frame(`patient_num` = dat.part[,nm.id])
  for(i in 1:length(out)){
    method = out[[i]]
    feat = method$feat

    if(length(feat) == 1){
      dat.part.filter = data.frame(dat.part[, feat])
      colnames(dat.part.filter) = feat
    }else{
      dat.part.filter = dat.part[, feat]
    }
    dat.part.filter = as.data.frame(cbind(dat.part[,nm.utl], dat.part.filter))
    colnames(dat.part.filter)[1] = nm.utl
    if(!is.null(nm.multi)){
      dat.part.filter = as.data.frame(cbind(dat.part[,nm.multi], dat.part.filter))
      colnames(dat.part.filter)[1] = nm.multi
    }

    b.all = data.frame(`coeff` = method$beta$theta, `feat` = method$beta$feat)
    S.norm <- as.matrix(dat.part.filter[,b.all$feat]) %*% matrix(b.all$coeff, ncol=1)

    ## Fit gaussian mixture model on S.norm, we only use the "length(nm.logS.ori) = 1" case:
    fit = S.norm
    pred.prob = cbind(pred.prob, fit)
  }
  colnames(pred.prob)[-1] = names(out)
  return(stats::na.omit(pred.prob))
}



KOMAP.eval <- function(pred.prob, gold.label, nm.pi = NULL, nm.y = 'Y', nm.id, method_nm){
  dat.merge = dplyr::left_join(gold.label, pred.prob, by = nm.id)
  dat.merge = stats::na.omit(dat.merge)
  Y <- dat.merge[, nm.y]
  auc_table <- c()
  F_table <- c()
  prev_vec <- c()
  label_num_vec <- c()
  # Since the sampling of gold label set is not completely at random, we need to include weights:
  if(!is.null(nm.pi)){
    w <- 1 / dat.merge[,nm.pi]
  }else{
    dat.merge$pi = w <- rep(1/nrow(dat.merge), nrow(dat.merge))
  }
  prev_vec <- c(prev_vec, mean(Y))
  label_num_vec <- c(label_num_vec, length(Y))
  num_method <- length(method_nm)
  auc_vec <- rep(0, num_method)
  F_vec <- rep(0, num_method)
  roc_lst <- vector('list', num_method)

  for (t in 1:num_method){
    # AUC
    auc_vec[t] <- AUC(Y, as.vector(dat.merge[,method_nm[t]]), wgt=w)
    # ROC table
    roc_lst[[t]] <- ROC(Y, as.vector(dat.merge[,method_nm[t]]), wgti=w, seq = seq(.01,.99,by=1e-5))[-1,]
    # Maximum F-score
    F_score_all <- 2 / (1 / roc_lst[[t]][,4] + 1 / roc_lst[[t]][,5])
    F_vec[t] <- max(F_score_all)
  }
  return(data.frame(`method` = method_nm,
                    `auc` = auc_vec,
                    `F_score_max` = F_vec)
         # `F_score_max` = F_vec
  )
}




KOMAP.sim_auc <- function(out, mus0, mus1, vars0, vars1, prev_Y, B = 10000){
  if(all(!is.na(mus0) & !is.na(mus1) & !is.na(vars0) & !is.na(vars1) &
         !is.null(out))){
    feat.all = colnames(vars0)
    names(mus0) = names(mus1) = colnames(vars0)
    auc_sim = c()
    for(i in 1:length(out)){
      feat.id = which(out[[i]]$beta$feat %in% colnames(vars0))
      feat.i = out[[i]]$beta$feat[feat.id]
      theta = out[[i]]$beta$theta[feat.id]
      mus0_part = mus0[feat.i]
      mus1_part = mus1[feat.i]
      vars0_part = vars0[feat.i, feat.i]
      vars1_part = vars1[feat.i, feat.i]

      Y = stats::rbinom(B, size = 1, prob = prev_Y)
      X_score = rep(0, B)
      X_score[Y == 0] = MASS::mvrnorm(n = sum(Y==0), mu = mus0_part %*% theta,
                                      Sigma = t(theta) %*% vars0_part %*% theta)
      X_score[Y == 1] = MASS::mvrnorm(n = sum(Y==1), mu = mus1_part %*% theta,
                                      Sigma = t(theta) %*% vars1_part %*% theta)
      auc_sim <- c(auc_sim, AUC(Y, X_score))
    }
    out_sim_re = data.frame(`method` = names(out),
                            `auc` = auc_sim)
  }
  return(out_sim_re)
}
