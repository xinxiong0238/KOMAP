#' Run komap main function
#'
#' @param input.cov A covariance matrix of the target disease with colnames and rownames equal to variable names.
#' @param target.code Main phecode of the target disease.
#' @param target.cui Main NLP feature (CUI) of the target disease, can be NULL if NLP features are not available.
#' @param nm.utl Variable name of health utility score.
#' @param dict Dictionary mapping feature id (the first column) to full description (the second column).
#' @param codify.feature A vector of codified features related to the target code. Can be generated by KESER or ONCE (Codisearch).
#' @param cuisearch.feature A vector of NLP features related to the target code. Can be generated by ONCE (CUIsearch).
#' @param pred If \code{TRUE}, predict disease scores for individual data.
#' @param eval.real If \code{TRUE}, evaluate model performance based on prediction of individual data with gold labels.
#' @param eval.sim If \code{TRUE}, evaluate model performance based on conditional covariance matrices, conditional mean vectors and prevalence of the target disease.
#' @param mu0 Conditional mean vector of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param mu1 Conditional mean vector of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same length and in the same feature order as \code{mu0}.
#' @param var0 Conditional covariance matrix of features given a negative label. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param var1 Conditional covariance matrix of features given a positive label. Must be provided if \code{eval.sim}=\code{TRUE} and must have the same dimension and in the same feature order as \code{var0}.
#' @param prev_Y Prevalence of the target disease. Must be provided if \code{eval.sim}=\code{TRUE}.
#' @param B The number of samples to calculate simulated AUC, given the conditional Gaussian assumption. Default is 10000.
#' @param dat.part Patient-level data for prediction. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param nm.id Name of the patient id column in \code{dat.part} and \code{gold.label}. Must be provided if \code{pred}=\code{TRUE} or \code{eval.real}.
#' @param gold.label Gold label for patients in \code{dat.part}, containing at least one id column and one label column. Must be provided if \code{eval.real}=\code{TRUE}.
#' @param nm.pi The column name of sample probability in \code{gold.label} if individuals in \code{gold.label} are generated with different probabilities. Default is \code{NULL}, meaning a uniform sample distribution.
#' @param nm.y The column name of labels in \code{gold.label}. Must be provided if \code{eval.real}=\code{TRUE}.
#' @returns A list containing estimation and/or prediction and/or evaluation results by running KOMAP.
#' @examples
#' codify.feature <- codify_RA$Variable[codify_RA$select == 1]
#' cuisearch.feature <- cui_RA$cui[cui_RA$select == 1]
#' input.cov <- cov_RA
#' target.code <- 'PheCode:714.1'
#' target.cui <- 'C0003873'
#' nm.utl <- 'utl'
#' nm.pi <- 'pi'
#' nm.id <- 'patient_num'
#' nm.y <- 'Y'
#' out <- KOMAP(input.cov, target.code, target.cui, nm.utl, dict,
#'                    codify.feature, cuisearch.feature,
#'                    pred = FALSE, eval.real = FALSE, eval.sim = TRUE,
#'                    mu0, mu1, var0, var1, prev_Y, B = 10000,
#'                    dat.part, nm.id, gold.label, nm.pi, nm.y)
#' @export
KOMAP <- function(input.cov, target.code, target.cui, nm.utl, dict,
                  codify.feature, cuisearch.feature,
                  pred = FALSE, eval.real = FALSE, eval.sim = TRUE,
                  mu0 = NULL, mu1 = NULL, var0 = NULL, var1 = NULL, prev_Y = NULL, B = 10000,
                  dat.part = NULL, nm.id = NULL, gold.label = NULL, nm.pi = NULL, nm.y = NULL){
  oldw <- getOption("warn")
  options(warn = -1)

  ### Check user's input
  KOMAP.est.check(input.cov, target.code, target.cui, nm.utl,
                  codify.feature, cuisearch.feature)
  out_main = KOMAP.est(input.cov, target.code, target.cui, nm.utl, dict,
                       codify.feature, cuisearch.feature)
  message('\nFinish estimating coefficients.')
  out = out_main$lst
  method_nm = names(out)
  feat.out = unique(unlist(sapply(out, function(x){x['feat']})))
  out_return = c(list(`est` = out_main))

  if(eval.sim){
    KOMAP.sim_auc.check(out, feat.out, mu0, mu1, var0, var1, prev_Y)
    out.sim = KOMAP.sim_auc(out, mu0, mu1, var0, var1, prev_Y, B = B)
    out_return = c(out_return, `sim_eval` = list(out.sim))
    message('Finish estimating AUC.')
  }

  if(pred){
    KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
    pred.prob = KOMAP.pred(out, dat.part, nm.utl, nm.id)
    out_return = c(out_return, `pred_prob` = list(pred.prob))
    message('Finish predicting scores.')
  }

  if(eval.real){
    if(pred){
      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return,
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }else{
      KOMAP.pred.check(out, feat.out, dat.part, nm.utl, nm.id)
      pred.prob = KOMAP.pred(out, dat.part, nm.utl, nm.id)

      KOMAP.eval.check(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out.eval = KOMAP.eval(pred.prob, gold.label, nm.pi, nm.y, nm.id, method_nm)
      out_return = c(out_return, `pred_prob` = list(pred.prob),
                     `real_eval` = list(out.eval))
      message('Finish evaluating model prediction.')
    }
  }
  options(warn = oldw)
  return(out_return)
}


KOMAP.est <- function(input.cov, target.code, target.cui, nm.utl, dict,
                                codify.feature, cuisearch.feature){
  out.all = c()
  parent.code0 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+')
  parent.code1 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{1}')
  parent.code2 = stringr::str_extract(target.code, 'PheCode\\:[0-9]+\\.[0-9]{2}')
  if(!is.na(parent.code2)){
    idd = which(!rownames(input.cov) %in% c(parent.code0, parent.code1))
    input.cov = input.cov[idd, idd]
  }else{
    if(!is.na(parent.code1)){
      idd = which(!rownames(input.cov) %in% c(parent.code0))
      input.cov = input.cov[idd, idd]
    }
  }

  if(is.null(codify.feature)) codify.feature = target.code
  if(is.null(cuisearch.feature)) cuisearch.feature = target.cui

  out = gen.KOMAP.est.table(input.cov, nm.utl, target.code, target.cui, dict,
                  codify.feature = codify.feature, cuisearch.feature = cuisearch.feature)
  out.df = sapply(1:length(out), function(i){
    a = data.frame(`disease` = target.code,
                   `method` = names(out)[i],
                   `target` = paste0(out[[i]]$target, collapse = ', '),
                   `feat` = out[[i]]$beta$feat,
                   `coeff` = out[[i]]$beta$theta)
    return(a)
  }, simplify = FALSE)
  out.re = data.table::rbindlist(out.df)
  # out.re = out.re[out.re$method %in% str_remove(input$komap_feat,"combine\\_"), ]
  out.all = rbind(out.all, out.re)
  out.all$desc = dict[match(out.all$feat, dict[,1]),2]
  out.all = out.all[,c('disease', 'method', 'target', 'feat', 'desc', 'coeff')]
  out.all$coeff = as.numeric(out.all$coeff)
  out.all = out.all[order(out.all$coeff, decreasing = TRUE), ]
  out.all$desc[out.all$feat == nm.utl] = 'Healthcare Utility'
  # out.all$desc = word2vec::txt_clean_word2vec(out.all$desc)
  return(list(`long_df` = out.all,
              `lst` = out))
}


gen.KOMAP.est.table <- function(input.cov, nm.utl, target.code, target.cui, dict,
                      codify.feature, cuisearch.feature){
  if(is.null(target.code) & is.null(target.cui)){
    warning("You must at least specify one target (target.code or target.cui)!")
    return(0)
  }
  alpha.glmnent = 0.15
  ## By default: input.cov = XTX/N, X=(1,X_{sur},X_{komap},X_{u})

  colnames(input.cov)[stringr::str_detect(colnames(input.cov), '^CCS-PCS')] =
    stringr::str_replace(colnames(input.cov)[stringr::str_detect(colnames(input.cov), '^CCS-PCS')],
                '^CCS-PCS', 'CCS')
  rownames(input.cov)[stringr::str_detect(rownames(input.cov), '^CCS-PCS')] =
    stringr::str_replace(rownames(input.cov)[stringr::str_detect(rownames(input.cov), '^CCS-PCS')],
                '^CCS-PCS', 'CCS')

  nm.others = colnames(input.cov)
  nm.others = nm.others[!nm.others %in% c(target.code, target.cui, nm.utl)]
  all.nm = c(target.code, target.cui, nm.others, nm.utl)
  feat.cov = input.cov[all.nm, all.nm]
  nm.feat.all = sort(colnames(feat.cov))
  nm.cui = nm.feat.all[stringr::str_detect(nm.feat.all, "^C[0-9]{7}")]
  nm.code = setdiff(nm.feat.all, c(nm.cui, nm.utl))

  #### Both provide target code and target cui
  if(!is.null(target.code) & !is.null(target.cui)){
    nm.code.filter = codify.feature
    nm.cui.filter.final = cuisearch.feature

    nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov))
    nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov))

    out = c()
    # main ICD + keser
    method =  list(`feat` = unique(c(nm.code.filter, target.code)),
                   `target` = target.code)
    out = c(out, `mainICD + codify` = list(method))


    # main ICDNLP + keser + NLP
    method = list(`feat` = unique(c(nm.code.filter, nm.cui.filter.final, target.code, target.cui)),
                  `target` = c(target.code, target.cui))
    out = c(out, `mainICDNLP + codify & NLP` = list(method))
  }else{
    if(!is.null(target.code)){
      nm.code.filter = codify.feature
      nm.code.filter = intersect(stats::na.omit(nm.code.filter), colnames(feat.cov))

      out = c()
      # main ICD + codify
      method =  list(`feat` = c(nm.code.filter, target.code),
                     `target` = target.code)
      out = c(out, `mainICD + codify` = list(method))
    }else{
      if(!is.null(target.cui)){
        nm.cui.filter.final = cuisearch.feature
        nm.cui.filter.final = intersect(stats::na.omit(nm.cui.filter.final), colnames(feat.cov))

        out = c()
        # main NLP + NLP final weight
        method = list(`feat` = unique(c(nm.cui.filter.final, target.cui, target.code)),
                      `target` = target.cui)
        out = c(out, `mainNLP + NLP_final` = list(method))
      }
    }
  }

  for(i in 1:length(out)){
    method = out[[i]]
    feat = method$feat; target = method$target
    if(length(target) == 1){

      ## do we need constant or not??
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      all.nm = c(target, setdiff(feat, target), nm.utl)
      feat.cov.part = feat.cov[all.nm, all.nm]

      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      colnames(U) = rownames(U) = colnames(feat.cov.part)
      #! reg1 = stats::lm(U[, target] ~ 0 + U[, 1] + U[, nm.utl])
      reg1 = stats::lm(U[, target] ~ 0 + U[, nm.utl])
      U_new = U; U_new[, target] = reg1$residuals
      alpha = reg1$coefficients
      #! U_new = U_new[,-1]
      # U_new = U_new[c(target, setdiff(feat, target), nm.utl),c(target, setdiff(feat, target), nm.utl)]
      Y = U_new[, target]
      XTX <- t(U_new) %*% U_new
      XTY <- t(U_new) %*% Y
      #!!!ask molei W_vec <- diag(XTX) * lambda
      # W_vec <- rep(lambda, nrow(XTX))
      W_vec <- diag(XTX)
      W <- diag(W_vec)

      if (ncol(W) == 0){
        W <- 0
      }
      cv.fit <- glmnet::cv.glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = F)
      model.fit <- glmnet::glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = F,
                          lambda = cv.fit$lambda.min)
      b.all <- as.vector(model.fit$beta)
      # b.all.ori <- solve(XTX + W) %*% XTY
      score = U_new %*% b.all
      n_komap = length(setdiff(feat, target))
      alpha_ma = cbind(c(1, rep(0, n_komap), -alpha),
                       rbind(matrix(0, 1, n_komap + 1),
                             diag(1, nrow = n_komap + 1)))

      theta = alpha_ma %*% b.all
      beta.all <- data.frame(`feat` = rownames(U), `theta` = theta)
      beta.all$beta = NA; beta.all$beta[match(colnames(XTX), beta.all$feat)] = b.all
      method$beta = beta.all
      method$est_score = score
      out[[i]] = method
    }else{
      b.all = score = alpha = c()

      # ##!! first together regress out utl for main codes and then estimate beta together!!
      #! all.nm = c('constant', target, setdiff(feat, target), nm.utl)
      all.nm = c(target, setdiff(feat, target), nm.utl)
      feat.cov.part = feat.cov[all.nm, all.nm]
      U = svd(feat.cov.part)
      U = t(U$u %*% sqrt(diag(U$d)))
      colnames(U) = rownames(U) = colnames(feat.cov.part)
      #! U_new = U[,-1]
      U_new = U
      for(j in 1:length(target)){
        target.j = target[j]
        reg1 = stats::lm(U[, target.j] ~ 0 + U[, nm.utl])
        U_new[, target.j] = reg1$residuals
        alpha = cbind(alpha, reg1$coefficients)
      }

      for(j in 1:length(target)){
        target.j = target[j]
        Y = U_new[, target.j]
        XTX <- t(U_new) %*% U_new
        XTY <- t(U_new) %*% Y
        #!!!! W_vec <- diag(XTX) * lambda
        # W_vec <- rep(lambda, nrow(XTX))
        W_vec <- diag(XTX)
        W <- diag(W_vec)

        if (ncol(W) == 0){
          W <- 0
        }
        cv.fit <- glmnet::cv.glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = FALSE)
        model.fit <- glmnet::glmnet(U_new, Y, intercept = F, alpha = alpha.glmnent, standardize = FALSE,
                            lambda = cv.fit$lambda.min)
        b.all0 <- as.vector(model.fit$beta)
        # b.all0 = solve(XTX + W) %*% XTY
        b.all <- cbind(b.all, b.all0)
        score = cbind(score, as.matrix(U_new %*% b.all0, ncol = 1))
      }


      n_komap = length(setdiff(feat, target))
      alpha_ma = cbind(c(1, 0, rep(0, n_komap), -alpha[, 1]),
                       c(0, 1, rep(0, n_komap), -alpha[, 2]),
                       rbind(matrix(0, 2, n_komap + 1),
                             diag(1, nrow = n_komap + 1)))

      pca.score = stats::princomp(U %*% alpha_ma %*% b.all)
      gamma = pca.score$loadings[,1]

      theta = alpha_ma %*% b.all %*% gamma
      beta.all <- data.frame(`feat` = rownames(U), `theta` = theta)
      beta.all$beta_ICD = beta.all$beta_NLP = NA
      beta.all$beta_ICD[match(rownames(b.all), beta.all$feat)] = b.all[,1]
      beta.all$beta_NLP[match(rownames(b.all), beta.all$feat)] = b.all[,2]
      method$beta = beta.all
      method$est_score = U_new %*% b.all %*% gamma
      out[[i]] = method
    }
  }
  return(out)
}




KOMAP.pred <- function(out, dat.part, nm.utl, nm.id = 'patient_num'){
  pred.prob = data.frame(`patient_num` = dat.part[,nm.id])
  for(i in 1:length(out)){
    method = out[[i]]
    feat = method$feat

    if(length(feat) == 1){
      dat.part.filter = data.frame(dat.part[, feat])
      colnames(dat.part.filter) = feat
    }else{
      dat.part.filter = dat.part[, feat]
    }
    dat.part.filter = as.data.frame(cbind(dat.part[,nm.utl], dat.part.filter))
    colnames(dat.part.filter)[1] = nm.utl

    b.all = data.frame(`coeff` = method$beta$theta, `feat` = method$beta$feat)
    S.norm <- as.matrix(dat.part.filter[,b.all$feat]) %*% matrix(b.all$coeff, ncol=1)

    ## Fit gaussian mixture model on S.norm, we only use the "length(nm.logS.ori) = 1" case:
    fit = S.norm
    pred.prob = cbind(pred.prob, fit)
  }
  colnames(pred.prob)[-1] = names(out)
  return(pred.prob)
}



KOMAP.eval <- function(pred.prob, gold.label, nm.pi = NULL, nm.y = 'Y', nm.id, method_nm){
  dat.merge = dplyr::left_join(gold.label, pred.prob, by = nm.id)
  Y <- dat.merge[, nm.y]
  auc_table <- c()
  F_table <- c()
  prev_vec <- c()
  label_num_vec <- c()
  # Since the sampling of gold label set is not completely at random, we need to include weights:
  if(!is.null(nm.pi)){
    w <- 1 / dat.merge[,nm.pi]
  }else{
    dat.merge$pi = w <- rep(1/nrow(dat.merge), nrow(dat.merge))
  }
  prev_vec <- c(prev_vec, mean(Y))
  label_num_vec <- c(label_num_vec, length(Y))
  num_method <- length(method_nm)
  auc_vec <- rep(0, num_method)
  F_vec <- rep(0, num_method)
  roc_lst <- vector('list', num_method)

  for (t in 1:num_method){
    # AUC
    auc_vec[t] <- AUC(Y, as.vector(dat.merge[,method_nm[t]]), wgt=w)
    # ROC table
    roc_lst[[t]] <- ROC(Y, as.vector(dat.merge[,method_nm[t]]), wgti=w, seq = seq(.01,.99,by=1e-5))[-1,]
    # Maximum F-score
    F_score_all <- 2 / (1 / roc_lst[[t]][,4] + 1 / roc_lst[[t]][,5])
    F_vec[t] <- max(F_score_all)
  }
  return(data.frame(`method` = method_nm,
                    `auc` = auc_vec,
                    `F_score_max` = F_vec)
                    # `F_score_max` = F_vec
  )
}




KOMAP.sim_auc <- function(out, mus0, mus1, vars0, vars1, prev_Y, B = 10000){
  if(all(!is.na(mus0) & !is.na(mus1) & !is.na(vars0) & !is.na(vars1) &
         !is.null(out))){
    feat.all = colnames(vars0)
    names(mus0) = names(mus1) = colnames(vars0)
    auc_sim = c()
    for(i in 1:length(out)){
      feat.id = which(out[[i]]$beta$feat %in% colnames(vars0))
      feat.i = out[[i]]$beta$feat[feat.id]
      theta = out[[i]]$beta$theta[feat.id]
      mus0_part = mus0[feat.i]
      mus1_part = mus1[feat.i]
      vars0_part = vars0[feat.i, feat.i]
      vars1_part = vars1[feat.i, feat.i]

      Y = stats::rbinom(B, size = 1, prob = prev_Y)
      X_score = rep(0, B)
      X_score[Y == 0] = MASS::mvrnorm(n = sum(Y==0), mu = mus0_part %*% theta,
                                      Sigma = t(theta) %*% vars0_part %*% theta)
      X_score[Y == 1] = MASS::mvrnorm(n = sum(Y==1), mu = mus1_part %*% theta,
                                      Sigma = t(theta) %*% vars1_part %*% theta)
      auc_sim <- c(auc_sim, AUC(Y, X_score))
    }
    out_sim_re = data.frame(`method` = names(out),
                         `auc` = auc_sim)
  }
  return(out_sim_re)
}
