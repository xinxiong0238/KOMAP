---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# KOMAP

<!-- badges: start -->
<!-- badges: end -->

The goal of KOMAP is to fit an unsupervised phenotyping system which does not require manual chart review to acquire gold standard labels for algorithm training and validation. The online algorithm only requires summary-level covariance matrix for coefficient training. To get a quick model evaluation without individual-level data, users can upload conditional mean vector and covariance matrix to obtain a simulated model AUC. KOMAP can deal with cases when both codified and NLP features are available, or when only one feature type is at hand (just leave `target.code` or `target.cui` equal to `NULL` if not available). 

## Installation

You can install the development version of KOMAP from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("xinxiong0238/KOMAP")
```


## Dara preprocessing

### Input covariance matrix
One of the KOMAP algorithm inputs is the covariance matrix of the clinical features (i.e., log(count+1)) derived from your target population. To obtain the covariance matrix, we start from the raw EHR records. Note in the stored fake ehr data, we only include 5 patients and 2 different ehr codes - lab code and diagnostic ICD code (DIAG-ICD9).
```{r}
library(KOMAP)
head(fake_ehr)
```

We need to first calculate the raw concept count once per day for each patient(i.e., for those raw codes that show up more than one time in a day, treat as one time):

```{r message=FALSE, warning=FALSE}
library(dplyr)
fake_ehr_raw_count = fake_ehr %>% 
  group_by(patient_num, concept_type, concept_code) %>%
  summarise(count_once_per_day = length(unique(days_since_admission)))
head(fake_ehr_raw_count)
```

Then for diagnostic ICD code, we need to roll them up to phecode level. An toy example of the mapping file is stored in the package:
```{r}
head(phecode_map)
```

For each patient, the phecode count is equal to the sum of all its descendant ICD code once-per-day count:

```{r}
fake_ehr_rollup_count_phecode = left_join(fake_ehr_raw_count %>% 
                                            filter(concept_type == 'DIAG-ICD9'), phecode_map)
fake_ehr_rollup_count_phecode = fake_ehr_rollup_count_phecode %>%
  group_by(patient_num, concept_type, Phecode) %>%
  summarise(count = sum(count_once_per_day)) %>%
  mutate(concept_code = Phecode) %>%
  select(!Phecode)
```

Then, we combine the rolled up phecode count and raw loinc count together:
```{r}
fake_ehr_count_loinc = fake_ehr_raw_count %>% filter(concept_type == 'LAB-LOINC') %>%
  mutate(count = count_once_per_day,
         concept_code = paste0('LOINC:', concept_code)) %>%
  select(!count_once_per_day)
fake_ehr_count = rbind(fake_ehr_count_loinc, fake_ehr_rollup_count_phecode)
head(fake_ehr_count)
```

Then we transform the data to the wide format, conduct logarithm transformation, and calculate the covariance matrix:
```{r}
fake_ehr_count_wide = tidyr::pivot_wider(fake_ehr_count, id_cols = c('patient_num'),
                                         names_from = 'concept_code', values_from = 'count')
fake_ehr_count_wide[is.na(fake_ehr_count_wide)] = 0
fake_ehr_logcount_wide = fake_ehr_count_wide
fake_ehr_logcount_wide[,-1] = log(fake_ehr_logcount_wide[, -1] + 1)
fake_ehr_cov = cov(fake_ehr_logcount_wide[, -1])
fake_ehr_cov[1:3,1:3]
```

Note that it may be beneficial to screen out patients who never have the diagnostic code of your target disease before calculating the covariance matrix. For example, if you are interesting in rheumatoid arthritis phenotyping task, it is suggested to focus on patients who had at least 1 count of `PheCode:714.1` in their EHR records.


### Input feature filters (optional)
To further filter out unrelated codes, you can specify a vector of codified features as well as a vector of NLP features (e.g., CUIs in the stored example). You can refer to [ONCE](https://shiny.parse-health.org/ONCE/), an online searching app that returns a dictionary of related codified features as well as NLP features based on knowledge extracted from online article corpus. The csv file you downloaded from ONCE app has the same format as `codify_RA` (or `cui_RA`) stored in the KOMAP pacakge.
```{r}
codify.feature <- codify_RA$Variable[codify_RA$high_confidence_level == 1]
head(codify.feature)
nlp.feature <- cui_RA$cui[cui_RA$high_confidence_level == 1]
head(nlp.feature)
```


If `codify.feature` or `nlp.feature` argument is not equal to NULL, then KOMAP will only take a subset of the covariance matrix corresponding to your input. You can also do the filtering on the input covariance matrix by yourself.


### Input conditional covariance matrix, conditional mean vector and prevalance (optional)
If you have some labeled data at hand and you want to quickly check KOMAP performance, this package provides a simulated AUC that only needs conditional covariance matrix, conditional mean vector and prevalence without any individual data. To generate such AUC, we start from `fake_ehr_label_logcount_wide` which was generated by the aforementioned process using another set of fake patients. The format is very similar to `fake_ehr_logcount_wide`, except that `fake_ehr_label_logcount_wide` has an additional column indicating the true label for each patient.
```{r}
fake_ehr_label_logcount_wide[1:3,1:5]
```

The conditional statistics are derived based on this label column.

```{r}
fake_ehr_var0 = cov(fake_ehr_label_logcount_wide %>% filter(Y == 0) %>% select(-c(Y, patient_num)))
fake_ehr_var1 = cov(fake_ehr_label_logcount_wide %>% filter(Y == 1) %>% select(-c(Y, patient_num)))
fake_ehr_mu0 = colMeans(fake_ehr_label_logcount_wide %>% filter(Y == 0) %>% select(-c(Y, patient_num)))
fake_ehr_mu1 = colMeans(fake_ehr_label_logcount_wide %>% filter(Y == 1) %>% select(-c(Y, patient_num)))
fake_ehr_prev = mean(fake_ehr_label_logcount_wide$Y)
```

Note that the two conditional matrices must have colnames and rownames, and the conditional mean vectors must have names.


### Input gold label individual data (optional)
If you want to obtain the accurate AUC value by providing individual count data, the input gold label data should have the format as `fake_ehr_label_count_wide` with one column indicating patient labels (the column nae should go to the `nm.y` argument). Additionally, you can have another column suggesting the sample probability (the column nae should go to the `nm.pi` argument) if each patient in the label data was sampled with unequal probability.

```{r}
fake_ehr_label_logcount_wide_pi[1:3,1:6]
```

### Input individual data for disease score prediction (optional)
If you have some unlabeled data and want to use KOMAP to perform disease score prediction, the input data should be similar to `fake_ehr_logcount_wide`. If only part of your individual data has labels (i.e., some patients have NA value on the `Y` column), KOMAP can still perform prediction by ignoring the `Y` column. You also need to assign the unique patient id to a column (i.e, `nm.id` argument) for your input individual data, so that the output prediction data frame will also have that column in case of mismatching issue.



## Toy example for how use stored input data

### Stored input data for phenotyping
To illustrate the requirement for input data format, users can refer to the toy examples stored in the package.

```{r}
library(KOMAP)
## Input covariance matrix
?cov_RA

## Input dictionary (can be NULL)
?dict_RA

## Input individual data to predict disease score and/or evaluate model performance (can be NULL)
?dat_part

```

### Phenotyping Example

This is a basic example of how to use the main function in the KOMAP package to perform model training, score prediction and model evaluation with built-in toy rheumatoid arthritis data.

```{r example}
codify.feature <- codify_RA$Variable[codify_RA$high_confidence_level == 1]
nlp.feature <- cui_RA$cui[cui_RA$high_confidence_level == 1]
input.cov <- cov_RA
target.code <- 'PheCode:714.1'
target.cui <- 'C0003873'
nm.utl <- 'utl'
nm.pi <- 'pi'
nm.id <- 'patient_num'
nm.y <- 'Y'
dat.part <- dat_part

## Only fit the model without any validation and without feature screening
out_0 <- KOMAP(input.cov, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
             pred = FALSE, eval.real = FALSE, eval.sim = FALSE)

## Only fit the model without any validation
out_1 <- KOMAP(input.cov, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
             codify.feature, nlp.feature,               
             pred = FALSE, eval.real = FALSE, eval.sim = FALSE)

## Fit the model and calculate simulated AUC
out_2 <- KOMAP(input.cov, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
             codify.feature, nlp.feature,                            
             pred = FALSE, eval.real = FALSE, eval.sim = TRUE,
             mu0, mu1, var0, var1, prev_Y, B = 10000)

## If individual data is provided, KOMAP can perform disease score prediction
out_3 <- KOMAP(input.cov, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
             codify.feature, nlp.feature,                          
             pred = TRUE, eval.real = FALSE, eval.sim = FALSE,
             dat.part = dat.part, nm.id = nm.id)

## If individual data and gold label are provided, KOMAP can perform disease score prediction and calculate the true AUC
out_4 <- KOMAP(input.cov, target.code, target.cui, nm.utl, nm.multi = NULL, dict_RA,
             codify.feature, nlp.feature,                           
             pred = TRUE, eval.real = TRUE, eval.sim = FALSE,
             dat.part = dat.part, nm.id = nm.id, nm.pi = nm.pi, nm.y = nm.y)
```
